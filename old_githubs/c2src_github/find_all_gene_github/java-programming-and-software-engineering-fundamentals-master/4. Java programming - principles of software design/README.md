# Java Programming: Principles of Software Design

### About the Course

Solve real world problems with Java using multiple classes. Learn how to create programming solutions that scale using Java interfaces. Recognize that software engineering is more than writing code - it also involves logical thinking and design. By the end of this course you will have written a program that analyzes and sorts earthquake data, and developed a predictive text generator.

After completing this course, you will be able to:

1. Use sorting appropriately in solving problems;
2. Develop classes that implement the Comparable interface;
3. Use timing data to analyze empirical performance;
4. Break problems into multiple classes, each with their own methods;
5. Determine if a class from the Java API can be used in solving a particular problem;
6. Implement programming solutions using multiple approaches and recognize tradeoffs;
7. Use object-oriented concepts including interfaces and abstract classes when developing programs;
8. Appropriately hide implementation decisions so they are not visible in public methods; and
9. Recognize the limitations of algorithms and Java programs in solving problems.
10. Recognize standard Java classes and idioms including exception-handling, static methods, java.net, and java.io packages.

### Schedule:

#### Week 1: Earthquakes: Programming and Interfaces

In this module, we will introduce a data set containing details about earthquakes around the world. You will learn how to pull this data into a program, search through the data, and filter the data based on desired criteria. By the end of this module, you will be able to (1) write programs that include multiple classes and ArrayLists of class types, (2) find the maximum value in an ArrayList, (3) use a Filter interface to search through data, (4) implement interfaces with method signatures, and (5) combine several filters together.

#### Week 2: Earthquakes: Sorting Algorithms

In this module, you will continue using real earthquake data to explore several sorting algorithms. You will learn how to implement a selection sort and a bubble sort, then be introduced to a Java method Collections.sort, which sorts with much greater efficiency. By the end of this module, you will be able to (1) implement several sorting algorithms from scratch, (2) use efficient pre-existing sorting classes, (3) modify a class’s compareTo method to choose the criteria by which objects of that type are ordered, and (4) write classes that implement the Comparator interface to create interchangeable sorting criteria.

#### Week 3: N-Grams: Predictive Text 

In this module, you will explore some of the underlying concepts of predictive text. The first lesson will introduce random character generation and then how to train the character selection based on an input text. The second lesson will extend this concept to complete words. By the end of this module, you will be able to: (1) base random text generation on the frequency of characters in a training text, (2) collect a set of characters that occur in a text after randomly chosen initial character(s) to create a semi-random text, (3) extend the predictive text generation to use whole words, and (4) implement your own .equals method to compare complex data types.

#### Week 4: Java: Tools and Libraries for Everyone

As you reach the end of this series, you may wish to extend your Java experience to tools beyond those provided here. This module will cover some of the Java basic information that is needed to program without BlueJ or the edu.duke library. After completing this module, you will be able to: (1) write a main method to start a Java program in any programming environment, (2) use the “static” keyword to modify fields, (3) find alternative editors to use with Java, (4) use exceptions to debug your program and make it more robust, and (5) reference Java libraries that are necessary to read files without the edu.duke library.
